v
{-# LANGUAGE OverloadedStrings   #-}
v
{-# LANGUAGE ScopedTypeVariables #-}
v

v
-- | This file is a medley of various constructs and some corner cases
v 1
module Foo.Bar.Main
1 2            v
  ( Wibble(..), Wobble(Wobb, (!!!)), Woo
2 1 v
  -- * Operations
2 1 v
  , getFooByBar, getWibbleByWobble
1 v
  , module Bloo.Foo
1 v
) where
v 1

v 1
import           Control.Applicative (many, optional, pure, (<*>), (<|>))
v
import           Data.Foldable       (traverse_)
v
import           Data.Functor        ((<$>))
v
import           Data.List           (intercalate)
v
import           Data.Monoid         ((<>))
v
import qualified Options.Monad
v
import  qualified  Options.Applicative  as  Opts
v  1
import qualified Options.Divisible -- wibble (wobble)
v
   as Div
v  1
import qualified ProfFile.App        hiding (as, hiding, qualified)
v
import           ProfFile.App        (as, hiding, qualified)
v
import           ProfFile.App        hiding (as, hiding, qualified)
v
import qualified ProfFile.App        (as, hiding, qualified)
v                                     1
import           System.Exit         (ExitCode (..), exitFailure, qualified,
1                                     v
                                      Typey,
1                                     v
                                      wibble,
1                                     v
                                      Wibble)
v                                     1
import           System.FilePath     (replaceExtension, Foo(Bar, (:<)))
v                                     1
import           System.IO           (IOMode (..), hClose, hGetContents,
1                                     v
                                      hPutStr, hPutStrLn, openFile, stderr,
1                                     v
                                      stdout, MoarTypey)
v                                     1
import           System.Process      (CreateProcess (..), StdStream (..),
1                                     v
                                      createProcess, proc, waitForProcess)
2                       v             1

v                                     1
-- some chars that should be propertized
v                                     1
chars = ['c', '\n', '\'']
v

v
strings = ["", "\"\"", "\n\\ ", "\\"]
v
-- knownWrongEscape = "foo"\\"bar"
v

v       1
multiline1 = "\
1          v       2
        \ "
v       12
multiline2 = "\
1          v        2
         \"
v        1

v        1
difficult = foo' 'a' 2
v

v
foo = "wobble (wibble)"
v

v 1
class Get a s where
1 v
  get :: Set s -> a
1 v

v 1
instance {-# OVERLAPS #-} Get a (a ': s) where
1 v
  get (Ext a _) = a
1 v

v 1
instance {-# OVERLAPPABLE #-} Get a s => Get a (b ': s) where
1 v
  get (Ext _ xs) = get xs
1 v

v 1
data Options = Options
1 2            v
  { optionsReportType      :: ReportType
2 1 v
  , optionsProfFile        :: Maybe FilePath
1 v
  , optionsOutputFile      :: Maybe FilePath
1 v
  , optionsFlamegraphFlags :: [String]
1 v
  } deriving (Eq, Show)
v 1

v 1
class  (Eq a) => Ord a  where
1 v
  (<), (<=), (>=), (>)  :: a -> a -> Bool
v 1
  max @Foo, min        :: a -> a -> a
1 v

v 1
instance (Eq a) => Eq (Tree a) where
1 v
  Leaf a         == Leaf b          =  a == b
v 1
  (Branch l1 r1) == (Branch l2 r2)  =  (l1==l2) && (r1==r2)
v 1
  _              == _               =  False
1 v

v 2             1
data ReportType = Alloc   -- ^ Report allocations, percent
1               2 v
                | Entries -- ^ Report entries, number
1               v
                | Time    -- ^ Report time spent in closure, percent
1               v
                | Ticks   -- ^ Report ticks, number
1               v
                | Bytes   -- ^ Report bytes allocated, number
1               v
                deriving (Eq, Show)
v               1

v 1             2
type family G a where
1 v
  G Int = Bool
v 1
  G a   = Char
1 v

v 1
data Flobble = Flobble
1 2            v
  deriving (Eq) via (NonNegative (Large Int))
1 v
  deriving stock (Floo)
1 v
  deriving anyclass (WibblyWoo, OtherlyWoo)
v 1

v 1
newtype Flobby = Flobby
v

v1
foo ::
v   1
 Wibble -- wibble
v1  2
    -> Wobble -- wobble
v2  1
    -> Wobble -- wobble
v2  1
    -> Wobble -- wobble
v2  1
    -> (wob :: Wobble)
v2  1
    -> (Wobble -- wobble
23  1   v
    a b c)
v2  1

v1  2
(foo :: (Wibble Wobble)) foo
v1  2

v2 13
newtype TestApp
v  1
   (logger :: TestLogger)
1  v
   (scribe :: TestScribe)
1  v
   config
1  v
   a
v  1
   = TestApp a
v  1

v  1
optionsParser :: Opts.Parser Options
v 1
optionsParser = Options
1      2        v
  <$> (Opts.flag' Alloc (Opts.long "alloc" <> Opts.help "wibble")
3 1    2    v
       <|> Opts.flag' Entries (Opts.long "entry" <> Opts.help "wobble")
2 1    v
       <|> Opts.flag' Bytes   (Opts.long "bytes" <> Opts.help "i'm a fish"))
3 v    12
  <*> optional
3 1   v4  2
        (Opts.strArgument
3 4    51  2  v
          (Opts.metavar "MY-FILE" <>
2 3    45 1     v
           Opts.help "meh"))
2 3   v45 61

v 1    23 45
type PhantomThing
v

v      1
type SomeApi =
1 v                                            2
       "thing" :> Capture "bar" Index :> QueryParam "wibble" Text
2      v                                       1
                                               :> QueryParam "wobble" Natural
1      2                                       v
                                               :> Header TracingHeader TracingId
1      2                                       v
                                               :> ThingHeader
2 1    3                                       v
                                               :> Get '[JSON] (The ReadResult)
2      3              1                        v
  :<|> "thing" :> ReqBody '[JSON] Request
2 v    3              1                        4
                      :> Header TracingHeader TracingId
1 2    3              v                        4
                      :> SpecialHeader
1 2    3              v                        4
                      :> Post '[JSON] (The Response)
v 2    3              1                        4

v 1    2              3                        4
deriving instance FromJSONKey StateName
v
deriving anyclass instance FromJSON Base
v
deriving newtype instance FromJSON Treble
v

v 1
foo = do
1 v     2
  bar :: Wibble <- baz
v 1
  where baz = _
2 1     v
  -- checking that comments are ignored in layout
2 1     v
  -- and that a starting syntax entry is ok
v 1     2
        (+) = _
2 3     1     v

v 1     2
test = 1 `shouldBe` 1