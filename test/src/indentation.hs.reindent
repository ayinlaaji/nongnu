v
-- | Idealised indentation scenarios.
v
--
v
--   Bugs and unexpected behaviour in (re-)indentation may be documented here.
v
--
v
--   Lines marked "manual correction" indicate where we expect the user to
v
--   re-indent because it goes against our prediction. In some of these cases,
v
--   we could improve the guess with semantic information (e.g. if we know that
v
--   the RHS of a bind is only partially applied, then we probably mean to
v
--   continue that line instead of start a new one).
v
module Indentation where
v

v
import Foo.Bar
v                       1
import Foo.Baz hiding ( gaz,
2                     1 v
                        baz
2                     v 1
                      )
v                     1 2

v 1                   2 3
basic_do = do
1 v      2
  foo <- blah blah blah
v 2      1
  bar <- blah blah
2 1      v
         blah -- manual correction
2 1      v
         blah -- manual correction
v 1      2
  sideeffect
v 2   1  3
  sideeffect' blah
v 2      3  1
  let baz = blah blah
3 2   1  4       v
            blah -- manual correction
v 3   1  4  2
      gaz = blah
v 3   2 14  5
      haz =
3 1   2 v4  5
        blah
2 v   3 14  5
  pure faz -- manual correction
1 v   2 34  5

v 2  13 45  6
nested_do = -- manual correction
v       1
  do foo <- blah
v    2  1   3
     do bar <- blah -- same level as foo
v    2  1   4  3
        baz -- same level as bar
1    2  v   3  4

v    1  2   3  4
nested_where a b = foo a b
2 v 1
  where -- manual correction
1   v
    foo = bar baz -- indented
v   1
    baz = blah blah -- same level as foo
2   v   1
      where -- manual correction
1   2   v
        gaz a = blah -- indented
v   2   1
        faz = blah -- same level as gaz
1   2   v

v 1 2   3
let_in a b = let
1 v
  blah = bloo
v 1
  wobble _ = fish
v 2 1
  in
2 1 v
    flibble blah
1 v 2

v 2 3 1
implicit_let foo bar =
v     1
  let ?foo = foo
v 1   2
      ?bar = bar
v     1
  in  rar
v 1   2

v 1   2
case_of wibble = case wibble of
2 v 1
  Nothing   ->
2 1 v
    ""
v 2 1
  Just fish ->
2 1 v
    fish
1 v 2

v 1 2
lambda_case = \case
1 v
  Nothing   -> ""
v 1
  Just fish -> fish
1 v

v 1
dollars f Nothing = f $
1 v
  "" ""
1 v
  ""
v 1
dollars f (Just a) = f $ \s ->
1 v
  a
v 1

v 1
not_dollars = do
1 v      2
  db' <- liftIO $ readMVar db
v 2 1    3
  shouldGoHere <$>
2 1 v    3
    here
1 v 2    3

v 2 3    4  1
data Wibble = Wibble Int
1           v
            | Wobble Int
1           v
            | Vibble Int
v           1

v 1         2
data Record1 = Record1 {
1 v
  fieldA :: String
v 1
, fieldB :: String
v
}
v

v 1
data Record2 = Record2
2 1            v
  { fieldA :: String
1 v
  , fieldB :: String
1 v
  }
v 1

v 2            1
data Record3 = Record3 String Text
1              v
               deriving (Show)
v              1

v              1
data Record4 = Record3 String Text deriving (Show)
v

v        1
lists1 = [ foo
1        v
         , bar
2        v 1
         , [ blah
2        1 v
           , blah
2        1 v
           , blah ]
2        v 1
         ]
v        1 2

v 1      2 3
lists2 = [
1 v
  foo
v 1
, bar
v
]
v

v          1
lists3 = [ foo ,
1          v
           bar ]
v          1

v         12
tuples1 = ( foo
1         v
          , bar
2         v 1
          , ( blah
2         1 v
            , blah
2         1 v
            , blah )
2         v 1
          )
v         1 2

v 1       2 3
tuples2 = (
1 v
  foo
v 1
, bar
v
)
v

v           1
tuples3 = ( foo ,
1           v
            bar )
v           1

v           1
typesig :: a -> b -> c
v

v    1
types1 ::
2 1  v
     Monad m
2 v  1
  => a
1 v  2
  -> b
1 v  2
  -> c
v 1  2

v 21 3
types2 ::
2 1  v
   ( Monad m )
2 v1
  => a
1 v2
  -> b
1 v2
  -> c
v 12

v 12
types3 :: (Monad m, MemberLogger m)
2 1      v
  => a
1 v
  -> b
1 v
  -> c
v 1

v 2    1
types4 :: Monad m
2      1 v
       => (?log :: HasLogger m)
1      v
       => a
1      v
       -> b
1      v
       -> c
v      1

v      2  1
types5 :: (Monad m, MonadReader Foo m) =>
2        v1
          (?log :: HasLogger m) =>
1         v
          a -> b -> c