{-# LANGUAGE OverloadedStrings   #-}
v
{-# LANGUAGE ScopedTypeVariables #-}
v

v
-- | This file is a medley of various constructs and some corner cases
v
module Foo.Bar.Main
2 1              v
  ( Wibble(..), Wobble(Wobb, (!!!)), Woo
2 1                                    v
  -- * Operations
2 1                                    v
  , getFooByBar, getWibbleByWobble
2 1                v
  , module Bloo.Foo
1 2               v
) where
v 1

v 1
import           Control.Applicative (many, optional, pure, (<*>), (<|>))
v
import           Data.Foldable       (traverse_)
v
import           Data.Functor        ((<$>))
v
import           Data.List           (intercalate)
v
import           Data.Monoid         ((<>))
v
import qualified Options.Monad
v
import  qualified  Options.Applicative  as  Opts
v
import qualified Options.Divisible -- wibble (wobble)
2  1   v
   as Div
v  1
import qualified ProfFile.App        hiding (as, hiding, qualified)
v
import           ProfFile.App        (as, hiding, qualified)
v
import           ProfFile.App        hiding (as, hiding, qualified)
v
import qualified ProfFile.App        (as, hiding, qualified)
v
import           System.Exit         (ExitCode (..), exitFailure, qualified,
1                                     v
                                      Typey,
1                                     v
                                      wibble,
1                                     v
                                      Wibble)
v                                     1
import           System.FilePath     (replaceExtension, Foo(Bar, (:<)))
v
import           System.IO           (IOMode (..), hClose, hGetContents,
1                                     v
                                      hPutStr, hPutStrLn, openFile, stderr,
1                                     v
                                      stdout, MoarTypey)
v                                     1
import           System.Process      (CreateProcess (..), StdStream (..),
1                                     v
                                      createProcess, proc, waitForProcess)
1                       v             2

1                       v             2
-- some chars that should be propertized
v                                     1
chars = ['c', '\n', '\'']
1         v

v
strings = ["", "\"\"", "\n\\ ", "\\"]
1           v
-- knownWrongEscape = "foo"\\"bar"
1           v

v
multiline1 = "\
v       1
        \ "
v       1
multiline2 = "\
v        1
         \"
1        2     v

v        1
difficult = foo' 'a' 2
1                v

v
foo = "wobble (wibble)"
1       v

v
class Get a s where
1 v
  get :: Set s -> a
1 2                 v

1 v
instance {-# OVERLAPS #-} Get a (a ': s) where
2 1 v
  get (Ext a _) = a
1 2                 v

1 v
instance {-# OVERLAPPABLE #-} Get a s => Get a (b ': s) where
2 1 v
  get (Ext _ xs) = get xs
1 2                    v

1 v
data Options = Options
2 1              v
  { optionsReportType      :: ReportType
2 1                        v
  , optionsProfFile        :: Maybe FilePath
2 1                        v
  , optionsOutputFile      :: Maybe FilePath
2 1                        v
  , optionsFlamegraphFlags :: [String]
2 1                        v
  } deriving (Eq, Show)
1 v

v 1
class  (Eq a) => Ord a  where
2 1 v
  (<), (<=), (>=), (>)  :: a -> a -> Bool
2 1                                    v
  max @Foo, min        :: a -> a -> a
1 2                                   v

1 v
instance (Eq a) => Eq (Tree a) where
2 1 v
  Leaf a         == Leaf b          =  a == b
2 1                                           v
  (Branch l1 r1) == (Branch l2 r2)  =  (l1==l2) && (r1==r2)
2 1                                                  v
  _              == _               =  False
1 2                                      v

1 v
data ReportType = Alloc   -- ^ Report allocations, percent
2               1   v
                | Entries -- ^ Report entries, number
1               v
                | Time    -- ^ Report time spent in closure, percent
1               v
                | Ticks   -- ^ Report ticks, number
1               v
                | Bytes   -- ^ Report bytes allocated, number
1               v
                deriving (Eq, Show)
1               v

v               1
type family G a where
2 1 v
  G Int = Bool
2 1         v
  G a   = Char
1 2         v

1 v
data Flobble = Flobble
2 1              v
  deriving (Eq) via (NonNegative (Large Int))
1 v
  deriving stock (Floo)
1 v
  deriving anyclass (WibblyWoo, OtherlyWoo)
1 v

v 1
newtype Flobby = Flobby
1                  v

v
foo ::
21  v
 Wibble -- wibble
2v  1
    -> Wobble -- wobble
32  1    v
    -> Wobble -- wobble
32  1    v
    -> Wobble -- wobble
32  1    v
    -> (wob :: Wobble)
32  1    v
    -> (Wobble -- wobble
32  1     v
    a b c)
13  2    v

v2  1
(foo :: (Wibble Wobble)) foo
13  2                    v

v2  1
newtype TestApp
2  1    v
   (logger :: TestLogger)
1  v
   (scribe :: TestScribe)
1  v
   config
1  v
   a
1  v
   = TestApp a
1  2         v

v  1
optionsParser :: Opts.Parser Options
v
optionsParser = Options
2 1               v
  <$> (Opts.flag' Alloc (Opts.long "alloc" <> Opts.help "wibble")
3 2    1          v
       <|> Opts.flag' Entries (Opts.long "entry" <> Opts.help "wobble")
3 2    1              v
       <|> Opts.flag' Bytes   (Opts.long "bytes" <> Opts.help "i'm a fish"))
3 1    2v
  <*> optional
3 1    2v
        (Opts.strArgument
5 3    42 1     v
          (Opts.metavar "MY-FILE" <>
6 4    53 21    v
           Opts.help "meh"))
1 4    5v 32

1 5   v64 32
type PhantomThing
1    v

v
type SomeApi =
2 v    1
       "thing" :> Capture "bar" Index :> QueryParam "wibble" Text
3      2       v                               1
                                               :> QueryParam "wobble" Natural
2      1                                       v
                                               :> Header TracingHeader TracingId
2      1                                       v
                                               :> ThingHeader
2      1                                       v
                                               :> Get '[JSON] (The ReadResult)
3 1    2                                       v
  :<|> "thing" :> ReqBody '[JSON] Request
4 v    3              1                        2
                      :> Header TracingHeader TracingId
4 1    3              v                        2
                      :> SpecialHeader
4 1    3              v                        2
                      :> Post '[JSON] (The Response)
1 2    4              v                        3

v 2    4              1                        3
deriving instance FromJSONKey StateName
v
deriving anyclass instance FromJSON Base
v
deriving newtype instance FromJSON Treble
1        v

v
foo = do
2 1     v
  bar :: Wibble <- baz
2 1                  v
  where baz = _
3 2     1       v
  -- checking that comments are ignored in layout
3 2     1       v
  -- and that a starting syntax entry is ok
3 2     1       v
        (+) = _
1 3     2       v

1 3     2       v
test = 1 `shouldBe` 1
v