{-# LANGUAGE OverloadedStrings   #-}
v 1
{-# LANGUAGE ScopedTypeVariables #-}
v 1

v 1
-- | This file is a medley of various constructs and some corner cases
v 1
module Foo.Bar.Main
2 1              v
  ( Wibble(..), Wobble(Wobb, (!!!)), Woo
2 1 3                                  v
  -- * Operations
2 1 3                                  v
  , getFooByBar, getWibbleByWobble
2 1 3              v
  , module Bloo.Foo
1 2 3             v
) where
v 1 2

v 1 2
import           Control.Applicative (many, optional, pure, (<*>), (<|>))
v 1
import           Data.Foldable       (traverse_)
v 1
import           Data.Functor        ((<$>))
v 1
import           Data.List           (intercalate)
v 1
import           Data.Monoid         ((<>))
v 1
import qualified Options.Monad
v 1
import  qualified  Options.Applicative  as  Opts
v 1
import qualified Options.Divisible -- wibble (wobble)
2 31   v
   as Div
v  1 2
import qualified ProfFile.App        hiding (as, hiding, qualified)
v 1
import           ProfFile.App        (as, hiding, qualified)
v 1
import           ProfFile.App        hiding (as, hiding, qualified)
v 1
import qualified ProfFile.App        (as, hiding, qualified)
v 1
import           System.Exit         (ExitCode (..), exitFailure, qualified,
1 2                                   v
                                      Typey,
1                                     v 2
                                      wibble,
1                                     v 2
                                      Wibble)
v                                     1 2
import           System.FilePath     (replaceExtension, Foo(Bar, (:<)))
v 1
import           System.IO           (IOMode (..), hClose, hGetContents,
1 2                                   v
                                      hPutStr, hPutStrLn, openFile, stderr,
1                                     v 2
                                      stdout, MoarTypey)
v                                     1 2
import           System.Process      (CreateProcess (..), StdStream (..),
1 2                                   v
                                      createProcess, proc, waitForProcess)
1                       v             2 3

1 2                     v             3
-- some chars that should be propertized
v 1                                   2
chars = ['c', '\n', '\'']
1 2       v

v 1
strings = ["", "\"\"", "\n\\ ", "\\"]
1 2         v
-- knownWrongEscape = "foo"\\"bar"
1 2         v

v 1
multiline1 = "\
v 2     1
        \ "
v       1 2
multiline2 = "\
v 2      1
         \"
1        2 3   v

v 1      2
difficult = foo' 'a' 2
1 2              v

v 1
foo = "wobble (wibble)"
1 2     v

v 1
class Get a s where
1 v             2
  get :: Set s -> a
1 2 3           4   v

1 v             2
instance {-# OVERLAPS #-} Get a (a ': s) where
2 1 v                                      3
  get (Ext a _) = a
1 2 3               v                      4

1 v                                        2
instance {-# OVERLAPPABLE #-} Get a s => Get a (b ': s) where
2 1 v                                                     3
  get (Ext _ xs) = get xs
1 2 3                  v                                  4

1 v                                                       2
data Options = Options
2 1              v
  { optionsReportType      :: ReportType
2 1 3                      v
  , optionsProfFile        :: Maybe FilePath
2 1 3                      v
  , optionsOutputFile      :: Maybe FilePath
2 1 3                      v
  , optionsFlamegraphFlags :: [String]
2 1 3                      v
  } deriving (Eq, Show)
1 v 2

v 1
class  (Eq a) => Ord a  where
2 1 v                     3
  (<), (<=), (>=), (>)  :: a -> a -> Bool
2 1 3                     4            v
  max @Foo, min        :: a -> a -> a
1 2 3                     4           v

1 v                       2
instance (Eq a) => Eq (Tree a) where
2 1 v                            3
  Leaf a         == Leaf b          =  a == b
2 1 3                            4            v
  (Branch l1 r1) == (Branch l2 r2)  =  (l1==l2) && (r1==r2)
2 1 3                            4                   v
  _              == _               =  False
1 2 3                            4       v

1 v                              2
data ReportType = Alloc   -- ^ Report allocations, percent
2 3             1   v
                | Entries -- ^ Report entries, number
1               v 2
                | Time    -- ^ Report time spent in closure, percent
1               v 2
                | Ticks   -- ^ Report ticks, number
1               v 2
                | Bytes   -- ^ Report bytes allocated, number
1               v 2
                deriving (Eq, Show)
1               v 2

v 1             2
type family G a where
2 1 v             3
  G Int = Bool
2 1 3       v     4
  G a   = Char
1 2 3       v     4

1 v               2
data Flobble = Flobble
2 1              v
  deriving (Eq) via (NonNegative (Large Int))
1 v 2
  deriving stock (Floo)
1 v 2
  deriving anyclass (WibblyWoo, OtherlyWoo)
1 v 2

v 1
newtype Flobby = Flobby
1 2                v

v 1
foo ::
213 v
 Wibble -- wibble
2v 31
    -> Wobble -- wobble
23  1 4  v
    -> Wobble -- wobble
23  1 4  v
    -> Wobble -- wobble
23  1 4  v
    -> (wob :: Wobble)
23  1 4  v
    -> (Wobble -- wobble
23  1 4   v
    a b c)
12  3 4  v

v12 3
(foo :: (Wibble Wobble)) foo
123 4                    v

v12 3
newtype TestApp
2 31    v
   (logger :: TestLogger)
1  v 2
   (scribe :: TestScribe)
1  v 2
   config
1  v 2
   a
1  v 2
   = TestApp a
1  2 3       v

v 12
optionsParser :: Opts.Parser Options
v 1
optionsParser = Options
2 1               v
  <$> (Opts.flag' Alloc (Opts.long "alloc" <> Opts.help "wibble")
2 3 4  1          v
       <|> Opts.flag' Entries (Opts.long "entry" <> Opts.help "wobble")
2 3    1 4            v
       <|> Opts.flag' Bytes   (Opts.long "bytes" <> Opts.help "i'm a fish"))
2 1    3v4
  <*> optional
1 2 3  4v
        (Opts.strArgument
2 3    45 1     v
          (Opts.metavar "MY-FILE" <>
2 3    45 617   v
           Opts.help "meh"))
1 2    3v 45 6

1 2   v34 56
type PhantomThing
1 2  v

v 1
type SomeApi =
2 v    1
       "thing" :> Capture "bar" Index :> QueryParam "wibble" Text
2      3 4     v                               1
                                               :> QueryParam "wobble" Natural
1      2                                       v 3
                                               :> Header TracingHeader TracingId
1      2                                       v 3
                                               :> ThingHeader
1      2                                       v 3
                                               :> Get '[JSON] (The ReadResult)
2 1    3                                       v 4
  :<|> "thing" :> ReqBody '[JSON] Request
2 v 3  4              1                        5
                      :> Header TracingHeader TracingId
1 2    3              v 4                      5
                      :> SpecialHeader
1 2    3              v 4                      5
                      :> Post '[JSON] (The Response)
1 2    3              v 4                      5

v 1    2              3                        4
deriving instance FromJSONKey StateName
v 1
deriving anyclass instance FromJSON Base
v 1
deriving newtype instance FromJSON Treble
1 2      v

v 1
foo = do
2 1     v
  bar :: Wibble <- baz
2 1 3   4            v
  where baz = _
2 3 4   1       v
  -- checking that comments are ignored in layout
2 3 4   1       v
  -- and that a starting syntax entry is ok
2 3 4   1       v
        (+) = _
1 2 3   4 5     v

1 2 3   4       v
test = 1 `shouldBe` 1
v 1