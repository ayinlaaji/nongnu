module
Foo.Bar.Main
SYNTAX_(
Wibble
SYNTAX_(
..
SYNTAX_)
,
Wobble
SYNTAX_(
Wobb
,
SYNTAX_(
!!!
SYNTAX_)
SYNTAX_)
,
Woo
,
getFooByBar
,
getWibbleByWobble
,
module
Bloo.Foo
SYNTAX_)
where
import
Control.Applicative
SYNTAX_(
many
,
optional
,
pure
,
SYNTAX_(
<*>
SYNTAX_)
,
SYNTAX_(
<|>
SYNTAX_)
SYNTAX_)
import
Data.Foldable
SYNTAX_(
traverse_
SYNTAX_)
import
Data.Functor
SYNTAX_(
SYNTAX_(
<$>
SYNTAX_)
SYNTAX_)
import
Data.List
SYNTAX_(
intercalate
SYNTAX_)
import
Data.Monoid
SYNTAX_(
SYNTAX_(
<>
SYNTAX_)
SYNTAX_)
import
qualified
Options.Monad
import
qualified
Options.Applicative
as
Opts
import
qualified
Options.Divisible
as
Div
import
qualified
ProfFile.App
hiding
SYNTAX_(
as
,
hiding
,
qualified
SYNTAX_)
import
ProfFile.App
SYNTAX_(
as
,
hiding
,
qualified
SYNTAX_)
import
ProfFile.App
hiding
SYNTAX_(
as
,
hiding
,
qualified
SYNTAX_)
import
qualified
ProfFile.App
SYNTAX_(
as
,
hiding
,
qualified
SYNTAX_)
import
System.Exit
SYNTAX_(
ExitCode
SYNTAX_(
..
SYNTAX_)
,
exitFailure
,
qualified
,
Typey
,
wibble
,
Wibble
SYNTAX_)
import
System.FilePath
SYNTAX_(
replaceExtension
,
Foo
SYNTAX_(
Bar
,
SYNTAX_(
:<
SYNTAX_)
SYNTAX_)
import
System.IO
SYNTAX_(
IOMode
SYNTAX_(
..
SYNTAX_)
,
hClose
,
hGetContents
,
hPutStr
,
hPutStrLn
,
openFile
,
stderr
,
stdout
,
MoarTypey
SYNTAX_)
import
System.Process
SYNTAX_(
CreateProcess
SYNTAX_(
..
SYNTAX_)
,
StdStream
SYNTAX_(
..
SYNTAX_)
,
createProcess
,
proc
,
waitForProcess
SYNTAX_)
SYNTAX_'
c
SYNTAX_'
SYNTAX_'
SYNTAX_\
n
SYNTAX_'
SYNTAX_'
SYNTAX_\
'
SYNTAX_'
foo
=
"
wobble
SYNTAX_(
wibble
SYNTAX_)
"
class
Get
a
s
where
get
::
Set
s
->
a
instance
Get
a
SYNTAX_(
a
':
s
SYNTAX_)
where
get
SYNTAX_(
Ext
a
_
SYNTAX_)
=
a
instance
Get
a
s
=>
Get
a
SYNTAX_(
b
':
s
SYNTAX_)
where
get
SYNTAX_(
Ext
_
xs
SYNTAX_)
=
get
xs
data
Options
=
Options
SYNTAX_{
optionsReportType
::
ReportType
,
optionsProfFile
::
Maybe
FilePath
,
optionsOutputFile
::
Maybe
FilePath
,
optionsFlamegraphFlags
::
SYNTAX_[
String
SYNTAX_]
SYNTAX_}
deriving
SYNTAX_(
Eq
,
Show
SYNTAX_)
class
SYNTAX_(
Eq
a
SYNTAX_)
=>
Ord
a
where
SYNTAX_(
<
SYNTAX_)
,
SYNTAX_(
<=
SYNTAX_)
,
SYNTAX_(
>=
SYNTAX_)
,
SYNTAX_(
>
SYNTAX_)
::
a
->
a
->
Bool
max
@Foo
,
min
::
a
->
a
->
a
instance
SYNTAX_(
Eq
a
SYNTAX_)
=>
Eq
SYNTAX_(
Tree
a
SYNTAX_)
where
Leaf
a
==
Leaf
b
=
a
==
b
SYNTAX_(
Branch
l1
r1
SYNTAX_)
==
SYNTAX_(
Branch
l2
r2
SYNTAX_)
=
SYNTAX_(
l1==l2
SYNTAX_)
&&
SYNTAX_(
r1==r2
SYNTAX_)
_
==
_
=
False
data
ReportType
=
Alloc
|
Entries
|
Time
|
Ticks
|
Bytes
deriving
SYNTAX_(
Eq
,
Show
SYNTAX_)
type
family
G
a
where
G
Int
=
Bool
G
a
=
Char
data
Flobble
=
Flobble
deriving
SYNTAX_(
Eq
SYNTAX_)
via
SYNTAX_(
NonNegative
SYNTAX_(
Large
Int
SYNTAX_)
SYNTAX_)
deriving
stock
SYNTAX_(
Floo
SYNTAX_)
deriving
anyclass
SYNTAX_(
WibblyWoo
,
OtherlyWoo
SYNTAX_)
newtype
Flobby
=
Flobby
foo
::
Wibble
->
Wobble
->
Wobble
->
Wobble
->
SYNTAX_(
wob
::
Wobble
SYNTAX_)
->
SYNTAX_(
Wobble
a
b
c
SYNTAX_)
SYNTAX_(
foo
::
SYNTAX_(
Wibble
Wobble
SYNTAX_)
SYNTAX_)
foo
newtype
TestApp
SYNTAX_(
logger
::
TestLogger
SYNTAX_)
SYNTAX_(
scribe
::
TestScribe
SYNTAX_)
config
a
=
TestApp
a
optionsParser
::
Opts.Parser
Options
optionsParser
=
Options
<$>
SYNTAX_(
Opts.flag'
Alloc
SYNTAX_(
Opts.long
"
alloc
"
<>
Opts.help
"
wibble
"
SYNTAX_)
<|>
Opts.flag'
Entries
SYNTAX_(
Opts.long
"
entry
"
<>
Opts.help
"
wobble
"
SYNTAX_)
<|>
Opts.flag'
Bytes
SYNTAX_(
Opts.long
"
bytes
"
<>
Opts.help
"
i'm
a
fish
"
SYNTAX_)
SYNTAX_)
<*>
optional
SYNTAX_(
Opts.strArgument
SYNTAX_(
Opts.metavar
"
MY-FILE
"
<>
Opts.help
"
meh
"
SYNTAX_)
SYNTAX_)
type
PhantomThing
type
SomeApi
=
"
thing
"
:>
Capture
"
bar
"
Index
:>
QueryParam
"
wibble
"
Text
:>
QueryParam
"
wobble
"
Natural
:>
Header
TracingHeader
TracingId
:>
ThingHeader
:>
Get
'
SYNTAX_[
JSON
SYNTAX_]
SYNTAX_(
The
ReadResult
SYNTAX_)
:<|>
"
thing
"
:>
ReqBody
'
SYNTAX_[
JSON
SYNTAX_]
Request
:>
Header
TracingHeader
TracingId
:>
SpecialHeader
:>
Post
'
SYNTAX_[
JSON
SYNTAX_]
SYNTAX_(
The
Response
SYNTAX_)
deriving
instance
FromJSONKey
StateName
deriving
anyclass
instance
FromJSON
Base
deriving
newtype
instance
FromJSON
Treble
