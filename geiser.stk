;;; geiser.stk -- STklos Scheme implementation of the geiser protocols

;; Author: Jeronimo Pellegrini <j_p@aleph0.info>
;; Maintainer:
;; Keywords: languages, stklos, scheme, geiser
;; Homepage: 
;; Package-Requires: ((emacs "24.4") (geiser-core "1.0"))
;; SPDX-License-Identifier: BSD-3-Clause
;; Version: 1.0

(define-module GEISER

  (export geiser:eval
          geiser:load-file
          geiser:add-to-load-path
          geiser:macroexpand
          geiser:module-completions
          geiser:completions
          geiser:module-exports
          geiser:symbol-documentation
          geiser:autodoc
          geiser:no-values)

;; executes thunk, with all its output (standar and error) redirected
;; to a string.
(define (with-all-output-to-string thunk)
  (let ((out (open-output-string)))
    (with-error-to-port out
                        (lambda ()
                          (with-output-to-port out
                            thunk)))
    (close-output-port out)
    (get-output-string out)))


;; call-with-result wraps output from geiser functions.
;; The result is an assoc list with the keys:
;;
;; - result: the CAR is a list with the values returned
;; - output: the CDR is a string with the output
;;
;; Example:
;;
;; (call-with-result (lambda () (display "OK") 42))
;; =>  ((result "42") (output . "OK"))
;;
;;  (call-with-result (lambda () (display "OK") (values 1 2 3)))
;; =>  ((result "1" "2" "3") (output . "OK"))
;;
(define (call-with-result thunk)
  (let* ((result (if #f #f))
         (output (if #f #f)))
    
    (set! output
          (with-handler (lambda (exn)
                            (with-output-to-string
                              (lambda () (write (error-object-message exn)))))
                        (with-all-output-to-string
                         (lambda ()
                           (call-with-values thunk (lambda v (set! result v)))))))
    
    (set! result
          (cond
           ((list? result)
            (map (lambda (v) (with-all-output-to-string (lambda () (write v)))) result))
             ((eq? result (if #f #t))
              ;;              '())
              (list output))
             (else
              (list (with-all-output-to-string (lambda () (write result)))))))
    
    (let ((out-form
                 `((result ,@result)
                   (output . ,output))))
      (write out-form)
      (write-to-log '[[RESPONSE]])
      (write-to-log out-form))
    
    (newline)))

;; to log forms, use the following:
;; (define log (open-output-file "geiser-log.txt"))

(define (write-to-log form)
;;  (write form log)
;;  (newline log))
  (values))

;; evaluates form inside a module.
;; the result is in the same format as call-with-result.
;;
;; Example:
;; (geiser:eval #f '(begin (display "OK") (values 1 2 3)))
;; => ((result "1" "2" "3") (output . "OK"))
;;
(define (geiser:eval module-name form . rest)
  
  ;; All calls start at toplevel
  (let ((module (or (and (symbol? module-name )
			 (find-module module-name))
		    (find-module 'stklos))))
    (let ((thunk (guard
                     (err
                      (else
                       (write `((error (key . ,(error-object-message err)))))))
                   (lambda () (eval form module)))))
      
      (write-to-log form)
      (call-with-result thunk))))

;; Load a file

(define (geiser:load-file file)
  (let* ((file (if (symbol? file) (symbol->string file) file))
         (found-file (geiser-find-file file)))
    (call-with-result
     (lambda ()
       (when found-file
         (load found-file))))))

;; Geiser calls this function to add a string to STklos'
;; load path
(define (geiser:add-to-load-path path)
  (load-path (cons path (load-path))))

;; Geiser will call this procedure when it wants to
;; show the macro-expansion of a form.
(define (geiser:macroexpand form . rest)
  (format "~S" (macro-expand form)))



;; do not use string-index, because the native STklos version
;; is different from that in SRFI-13, and we can't tell in advance
;; what's the correct way to call it...
(define (name-match-with-start? prefix name i)
  (cond ((< (string-length name) (string-length prefix)) #f)
        ((>= i (string-length prefix)) #t)
        ((and (< i (string-length prefix))
              (eq? (string-ref prefix i)
                   (string-ref name i)))
         (name-match-with-start? prefix name (+ 1 i)))
        (else #f)))
(define (name-match? prefix name) (name-match-with-start? prefix name 0))

;; Geiser calls this procedure when it wants to complete
;; a module's name for the user. We check if prefix is
;; the prefix of a known module.
;;
;; Issue: we should be able to complete the names of
;; arbitrary modules, including those which were not
;; loaded yet, but that would be a bit too complex.
(define (geiser:module-completions prefix . rest)
  (filter (lambda (name) (name-match? prefix name))
          (map symbol->string
               (map module-name (all-modules)))))

;; symbol completion. not sure if completing with all the symbols
;; from the current module is OK, but it's a start...
(define (geiser:completions prefix)
  (filter (lambda (name) (name-match? prefix name))
          (map symbol->string
               (module-symbols (current-module)))))

;; used in module-exports...
(define-syntax push!
  (syntax-rules ()
    ((push! el lst)
     (set! lst (cons el lst)))))

;; given a module name (either symbol or string), return a list of
;; symbols exported by the module. This list will be used as an assoc
;; list, and the keys are:
;;
;; - "modules" - the CDR is a list of module names, each one wrapped in a list
;; - "procs" - the CDR is a list of procedure names, each one wrapped in a list
;; - "syntax" - the CDR is a list of macro names, each one wrapped in a list
;; - "vars" - the CDR is a list of variable names, each one wrapped in a list
;;
;; Example:
;;
;; (define-module x
;;   (export p q v s)
;;   (define v 100)
;;   (define (p) 200)
;;   (define (q) 300)
;;   (define-syntax s
;;     (syntax-rules ()
;;       ((s x) (- x)))))
;;
;;
;; (geiser:module-exports 'x)
;; => (list ("modules") ("procs" (p) (q)) ("syntax" (s)) ("vars" (v)))
;;
(define (geiser:module-exports module-name . rest)
  (cond ((string? module-name)
         (geiser:module-exports (string->symbol module-name)))
        ((symbol? module-name)
         (let ((module (find-module  module-name)))
           (let ((exports (module-exports module)))
             (let ((procs '())
                   (syntaxes '())
                   (vars '()))
               (for-each (lambda (name)
                           ;; STklos does not recognize macro names, but we can
                           ;; tell that, if it is exported, and does not have a value,
                           ;; then it is syntax!
                           (let ((obj (symbol-value name module :geiser-stklos--it-is-syntax)))
                             (cond ((procedure? obj)
                                    (push! (list name) procs))
                                   ((eq? obj :geiser-stklos--it-is-syntax)
                                    (push! (list name) syntaxes))
                                   (else
                                    (push! (list name) vars)))))
                         exports)
               `(list ("modules") ("procs" . ,procs) ("syntax" . ,syntaxes) ("vars" . ,vars))))))
        (else '())))


;; returns the documentation for a symbol
(define (geiser:symbol-documentation name)
  (with-output-to-string
    (lambda () (help (eval (eval name))))))

;; used for autodoc. returns the documentation for a symbol.
(define (geiser:autodoc names . rest)
  #f)
;;  (cond ((null? names) '())
;;        ((not (list? names))
;;         (geiser:autodoc (list names)))
;;        ((symbol? (car names))
;;         (with-output-to-string
;;           (lambda () (help (car names)))))
;;        (else "")))

;; The no-values identity
(define (geiser:no-values)
    (values))

(define geiser-stklos-load-paths (make-parameter '("" ".")))

(define (geiser-find-file file . rest)
  (when file
    (let ((paths (geiser-stklos-load-paths)))
      (define (try-find file paths)
        (cond
         ((null? paths) #f)
         ((file-exists? (string-append (car paths) file))
          (string-append (car paths) file))
         (else (try-find file (cdr paths)))))
      (try-find file paths))))

(define (geiser-add-to-load-path directory . rest)
  (let* ((directory (if (symbol? directory)
                        (symbol->string directory)
                        directory))
         (directory (if (not (equal? #\/ (string-ref directory (- (string-length directory)))))
                        (string-append directory "/")
                        directory)))
    (call-with-result
     (lambda ()
       (when (directory-exists? directory)
         (geiser-stklos-load-paths (cons directory (geiser-stklos-load-paths))))))))

(define (geiser-compile-file file . rest)
  #f)

(define (geiser-compile form module . rest)
  (error "STklos does not support compiling regions"))

) ;; END of module GEISER

;; standard boilerplate for loading modules:

(select-module STklos)
(import GEISER)
(provide "geiser")
