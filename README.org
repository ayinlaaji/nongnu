#+STARTUP: content
* geiser-kawa-java
** Project description

geiser-kawa-java is the emacs side of a geiser-kawa implementation that uses [[https://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]] for its Kawa side.

** Supported features

- eval
- load-file
- completions
- module-completions (very fragile atm)
- autodoc:
    - for scheme procedures
    - for java methods

** Unsupported features

geiser-related:
- macroexpand
- find-file
- symbol-location
- module-location
- symbol-documentation
- module-exports
- callers
- callees
- generic-methods
- (TODO) manual lookup: should work for both formats:
    - info: using emacs' Info-mode
    - epub: using emacs' eww browser

kawa- and java-specific:
- completion for java methods
- completion for java classes

** Supported Kawa versions
:PROPERTIES:
:CUSTOM_ID:       85b51f74-b1b2-4863-a888-0b11580321f3
:END:

Only versions of Kawa > 3.1 are supported, mostly due to the fact that before the 3.1 release some necessary Kawa classes were private.

** Try geiser-kawa without modifying your emacs configuration

1. Get Emacs, Cask, Maven and make them available through your $PATH
2. Clone this repository
3. cd into the cloned dir
4. Tell cask to install emacs dependencies with:
  : cask install
5. Pull [[http://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]] maven dependencies (the first time takes ~1 minute), compile them and start geiser-kawa's scratch buffer and repl with:
  : cask emacs -Q --load quickstart.el

The reason you don't need Kawa to try geiser-kawa is that =quickstart.el=:
1. calls =mvn package= (wrapped by =geiser-kawa-compile-java-dependencies=), which produces a jar that includes the compiled [[https://gitlab.com/groups/kashell/][Kawa's master branch]]
2. sets the variable =geiser-kawa-use-kawa-version-included-in-kawa-geiser= to =t=, to avoid issues with [[85b51f74-b1b2-4863-a888-0b11580321f3][older kawa versions]]

** Cask issue with geiser

If you use geiser as a dependency in a Cask project, Cask eagerly expands the =define-geiser-implementation= macro with =load-file-name= having the wrong value. The result is that geiser implementations in geiser do not work when geiser is managed as a dependency by Cask.

Link to the issue I've opened in Cask: https://github.com/cask/cask/issues/472.

As a (temporary?) workaround, geiser-kawa.el quotes =define-geiser-implementation= and wraps it an =eval= form, and that avoids:
1. macro expansion to happen during cask-cli.el execution
2. =load-file-name= having the wrong value of =<path-to-cask-cli.el>= instead of =<path-to-geiser-impl.el>=
As a side effect, using =(require 'geiser-kawa)= instead of =(require geiser)= also fixes the problem for the other implementations, but for this I don't understand why.

To summarize:
1. geiser-kawa depends on geiser
2. geiser as a dependency does not work with Cask (or vice-versa)
3. If in the emacs instance started with =cask emacs= you use =(require 'geiser-kawa)= instead of =(require 'geiser)=, geiser-kawa.el chain-requires geiser and (for some reason I don't understand) other geiser implementations start working

** Difference from [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]]

- The Kawa side of geiser-kawa-java uses [[https://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]], which is written using Kawa's Java API.
- The Kawa side of geiser-kawa-scheme is written directly in Kawa Scheme.
- I'm going to add more features to geiser-kawa-java but I probably won't port them to geiser-kawa-scheme.

geiser-kawa-java VS geiser-kawa-scheme - recap table:

|                                | geiser-kawa-java | geiser-kawa-scheme |
|--------------------------------+------------------+--------------------|
| Kawa side written with         | Kawa's Java API  | Kawa Scheme        |
| I'm going to add more features | Probably yes     | Probably not       |
