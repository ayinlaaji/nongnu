#+STARTUP: content
* geiser-kawa
** Project description

=geiser-kawa= is a geiser implementation for Kawa Scheme.

It has 2 parts:
- =geiser-kawa=: elisp package inside the =elisp= directory that gives the name to the whole project
- =kawa-geiser=: maven project written using Kawa's Java API that adds procedures called by geiser-kawa to a Kawa Scheme REPL

** Supported Kawa versions
:PROPERTIES:
:CUSTOM_ID:       85b51f74-b1b2-4863-a888-0b11580321f3
:END:

Only versions of Kawa > 3.1 are supported, mostly due to the fact that before the 3.1 release some necessary Kawa classes were private.

** Supported features

- geiser-related:
    - eval
    - load-file
    - completions
    - module-completions (very fragile atm)
    - macroexpand
    - autodoc:
        - for scheme procedures
        - for java methods
    - manual lookup:
        - remember to set variable =geiser-kawa-manual-path=
        - should work for both formats:
            - info: using emacs' Info-mode
            - epub: using emacs' eww browser
- kawa- and java-specific:
    - [[#7ca3650a-2658-42f0-8274-96f194768e11][Completion for java's package, class, field, method names]]

** Unsupported features

- geiser-related:
    - find-file
    - symbol-location
    - module-location
    - symbol-documentation
    - module-exports
    - callers
    - callees
    - generic-methods

** Try geiser-kawa without modifying your emacs configuration

1. Get Emacs and [[https://github.com/cask/cask][Cask]] and make them available through your $PATH
2. Clone this repository
  : git clone "https://gitlab.com/spellcard199/geiser-kawa.git"
3. cd into the cloned dir:
  : cd geiser-kawa
4. Tell cask to install emacs dependencies:
  : cask install
5. Pull kawa-geiser maven dependencies (the first time takes ~1 minute), compile them and start geiser-kawa's scratch buffer and repl:
  : cask emacs -Q --load quickstart.el
6. You should now have an emacs frame containing a scratch buffer in =geiser-mode= and a repl buffer, both with geiser-kawa support

To try geiser-kawa you need neither Maven nor Kawa:
- =mvnw= ([[https://github.com/takari/maven-wrapper][maven-wrapper]]) takes care of downloading a project-specific Maven version
- kawa-geiser has [[https://gitlab.com/groups/kashell/][Kawa's master branch]] as one of its dependencies. When =quickstart.el= calls =./mvnw package= (wrapped by =geiser-kawa-deps-mvnw-package=), it produces a jar that includes kawa-geiser and all its dependencies, including Kawa itself.

** About Autodoc

Double quotes around parameters: the reason why the arguments are enclosed in double quotes in autodoc is because special characters (e.g. =]=) aren't read as part of a symbol by the elisp reader that geiser relies on to display autodoc data. To work-around this limitation parameters are represented by using strings instead of symbols.

Parameter names: parameter names are retrieved using the =gnu.bytecode= package (included in Kawa) for reading local variables in Java methods' bytecode. Since parameters are not always present in bytecode as local variables, especially for java, when not available the parameter name defaults to =argN=, where =N= is a number.

** About completion for java's fields, methods and packages
:PROPERTIES:
:CUSTOM_ID:       7ca3650a-2658-42f0-8274-96f194768e11
:END:

The whole project is in a persistent "experimental" state, but this part even more so because it's based on assumptions I'm not sure about.

The main interactive elisp function is =geiser-kawa-complete-fmp-at-point=. By default, it's not bound to a key. (fmp stands for field-method-package).

Supported forms (with issues) are:
    - completion for package and class names: dot notation, like in java
    - completion for field and method names:
        - =field=, =slot-ref=
        - =static-field=
        - =invoke=
        - =invoke-static=
        - colon notation

How it works (the region getting part is quite rudimentray):
1. A region of the current buffer and cursor point inside it are sent to kawa-geiser, which uses [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]] for actual functionality. The region of the buffer goes:
     - from: either:
         - =(geiser-syntax--pop-to-top)=, if non-nil
         - =(line-beginning-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
     - to: either:
         - end of sexp beginning at toplevel, if =(geiser-syntax--pop-to-top)= is non-nil
         - =(line-end-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
2. [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]'s completion method is called passing code and cursor point

You can find some examples and known issues in [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]'README.

** Difference from [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]]

This project (geiser-kawa) is a translation/rewrite of [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]], which has been my first attempt at writing geiser-kawa. After geiser-kawa-scheme confirmed me that a geiser-kawa implementation was possible I decided to rewrite the Kawa side using Kawa's Java API, for the several reasons:
- Easier to add as a scripting language in Java projects: just add the jitpack resolver and this project's repository as a dependency
- Easier to inculde external java libraries via maven central for additional functionalities
- Tooling for Java is excellent, tooling for Kawa is not
- Fully static type checking: probably it's because I'm bad at programming, but it helps me a lot
- The old geiser-kawa's scheme implementation logic has been split in 2 projects:
    - [[https://www.gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]: functions that take care of getting data and general functionalities (e.g. output-capturing eval)
    - kawa-geiser:
        - the included maven project
        - gets data and features through kawa-devutil and wraps the result in the geiser protocol
- Possibility to share code between kawa-devutil and Kawa's Language Server
- Since kawa-devutil is now a different project from geiser-kawa, one could use it to avoid re-writing the data-getting logic if she/he wanted to implement a Kawa server for a tool other than geiser (e.g. nrepl, jupyter, swank/slime)

geiser-kawa VS geiser-kawa-scheme - recap table:

|                                | geiser-kawa     | geiser-kawa-scheme |
|--------------------------------+-----------------+--------------------|
| Kawa side written with         | Kawa's Java API | Kawa Scheme        |
| I'm going to add more features | Probably yes    | Probably not       |
