#+STARTUP: content
* geiser-kawa
** Project description

=geiser-kawa= is a geiser implementation for Kawa Scheme.

It has 2 parts:
- =geiser-kawa=: elisp package inside the =elisp= directory that gives the name to the whole project
- =kawa-geiser=: included maven project written using Kawa's Java API. When it's imported from a Kawa scheme REPL, procedures required by =geiser-kawa= are added to the Kawa environment

** Supported Kawa versions
:PROPERTIES:
:CUSTOM_ID:       85b51f74-b1b2-4863-a888-0b11580321f3
:END:

Only versions of Kawa > 3.1 are supported, mostly due to the fact that before the 3.1 release some necessary Kawa classes were private.

** Supported features

- geiser-related:
    - eval
    - load-file
    - completions
    - module-completions (very fragile atm)
    - macroexpand
    - autodoc:
        - for scheme procedures
        - for java methods
    - manual lookup:
        - remember to set variable =geiser-kawa-manual-path=
        - should work for both formats:
            - info: using emacs' Info-mode
            - epub: using emacs' eww browser
- kawa- and java-specific:
    - [[#7ca3650a-2658-42f0-8274-96f194768e11][Completion for Java package and class members (packages, classes, methods, fields)]]

** Unsupported features

- geiser-related:
    - find-file
    - symbol-location
    - module-location
    - symbol-documentation
    - module-exports
    - callers
    - callees
    - generic-methods

** Try geiser-kawa without modifying your emacs configuration

1. Get Emacs and [[https://github.com/cask/cask][Cask]] and make them available through your $PATH
2. Clone this repository
  : git clone "https://gitlab.com/spellcard199/geiser-kawa.git"
3. cd into the cloned dir:
  : cd geiser-kawa
4. Tell cask to install emacs dependencies:
  : cask install
5. Pull kawa-geiser maven dependencies (the first time takes ~1 minute), compile them and start geiser-kawa's scratch buffer and repl:
  : cask emacs -Q --load quickstart.el
6. You should now have an emacs frame containing a scratch buffer in =geiser-mode= and a repl buffer, both with geiser-kawa support

To try geiser-kawa you need neither Maven nor Kawa:
- =mvnw= ([[https://github.com/takari/maven-wrapper][maven-wrapper]]) takes care of downloading a project-specific Maven version
- kawa-geiser has [[https://gitlab.com/groups/kashell/][Kawa's master branch]] as one of its dependencies. When =quickstart.el= calls =./mvnw package= (wrapped by =geiser-kawa-deps-mvnw-package=), it produces a jar that includes kawa-geiser and all its dependencies, including Kawa itself.

** About manual lookup

To use the =geiser-doc-lookup-manual= feature you need a copy of the Kawa manual. You can either compile it from the Kawa source code or extract it from the pre-compiled Kawa release available on the Kawa website: https://www.gnu.org/software/kawa/Getting-Kawa.html.

Once you have the manual in either .info or .epub format, set the =geiser-kawa-manual-path= elisp variable to the path of the file.

** About Autodoc

Double quotes around parameters: the reason why the arguments are enclosed in double quotes in autodoc is because special characters (e.g. =]=) aren't read as part of a symbol by the elisp reader that geiser relies on to display autodoc data. To work-around this limitation parameters are represented by using strings instead of symbols.

Parameter names: parameter names are retrieved using the =gnu.bytecode= package (included in Kawa) for reading local variables in Java methods' bytecode. Since parameters are not always present in bytecode as local variables, especially for java, when not available the parameter name defaults to =argN=, where =N= is a number.

[[https://gitlab.com/kashell/Kawa/-/blob/master/gnu/kawa/lispexpr/LangObjType.java][LangObjType objects]]: these are special objects that may behave like procedures. When these are called as procedures, a constructor java method is called. This method does not have the same name as the symbol you insert in Kawa, so I decided that it was a good idea to show the method name as part of the displayed module, preceded by a colon. I don't know if it's a good idea, but it would be easy to change if it's not.

Autodoc for macros: not supported.

** About completion for Java package and class members (packages, classes, methods, fields)
:PROPERTIES:
:CUSTOM_ID:       7ca3650a-2658-42f0-8274-96f194768e11
:END:

The whole project is in a persistent "experimental" state, but this part even more so because it's based on assumptions that:
- I'm not sure about
- May not hold anymore if/when the Kawa compiler changes how accessing packages and class members is represented in its AST/Expression tree

The main interactive elisp function is =geiser-kawa-devutil-complete-at-point=. By default, it's not bound to any key.

Supported forms (with issues) are:
    - completion for package and class names: dot notation, like in java
    - completion for field and method names:
        - =field=, =slot-ref=
        - =static-field=
        - =invoke=
        - =invoke-static=
        - colon notation
Unsupported forms:
    - Kawa's star-colon notation (e.g: =(*:getClass "foobar")=)

How it works (the region getting part is quite rudimentray):
1. A region of the current buffer and cursor point inside it are sent to a Kawa procedure
2. kawa-devutil's pattern matching is run on the resulting Expression tree
3. If a match is found, the data is returned to Emacs

You can find some examples and known issues in [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]'s README.

** Extending =geiser-kawa=

Since you can get the result of a Kawa expression through geiser you can extend =geiser-kawa= blending both Elisp and Kawa, with the limitations due to the fact it's strings that are actually passed back and forth.

The rest of this section is an actual example. Let's say we wanted to extend =geiser-kawa= to list all the classes available in the default classloaders.

Since =kawa-devutil= and its dependencies are dependencies of =kawa-geiser=, we already have the [[https://github.com/classgraph/classgraph][Classgraph]] included in =kawa-geiser= even though =kawa-devutil= shades it to: =kawadevutil.shaded.io.github.classgraph=:

This is some simple Kawa code to get a list of all classes in the default classloaders using the ClassGraph library included in =kawa-geiser=:

#+BEGIN_SRC scheme
(let* ((cg (kawadevutil.shaded.io.github.classgraph.ClassGraph))
       (scanResult (invoke
                    (invoke
                     (invoke
                      cg
                      "enableSystemJarsAndModules")
                     "enableClassInfo")
                    "scan")))
  (scanResult:getAllClasses))
#+END_SRC

Now we can write an interactive elisp function that evaluates the code above each time it's called and then puts the result into an emacs buffer:

#+BEGIN_SRC emacs-lisp
(defun my-geiser-kawa-list-all-classes ()
  "A simple function that uses `geiser-kawa' to ask Kawa a list of all
the classes in the default classloaders of the current REPL and then
displays them in a dedicated buffer."
  (interactive)
  ;; Switch to dedicated buffer and create it if it doesn't exist.
  (switch-to-buffer-other-window
   (get-buffer-create "*geiser-kawa-classlist*"))
  ;; Clear buffer in case you already run the command once.
  (delete-region (point-min) (point-max))
  ;; Eval our Kawa code and insert result of evaluation in the buffer
  ;; we switched to above.
  (insert
   (geiser-kawa-util--eval/result
     ;; The same kawa code as above, quoted so that it's not evaluated
     ;; as elisp.
    '(let* ((cg (kawadevutil.shaded.io.github.classgraph.ClassGraph))
            (scanResult (invoke
                         (invoke
                          (invoke
                           cg
                           "enableSystemJarsAndModules")
                          "enableClassInfo")
                         "scan")))
       (scanResult:getAllClasses)))))
#+END_SRC

Once you evaluate this elisp function, if you have an active Kawa repl associated with the current buffer and use =M-x my-geiser-kawa-list-all-classes=, after some seconds (there are many thousands of classes) a list of classes will be displayed in a new buffer.

** Difference from [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]]

This project (geiser-kawa) is a translation/rewrite of [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]], which has been my first attempt at writing geiser-kawa. After geiser-kawa-scheme confirmed me that a geiser-kawa implementation was possible I decided to rewrite the Kawa side using Kawa's Java API, for the several reasons:
- Easier to add as a scripting language in Java projects: just add the jitpack resolver and this project's repository as a dependency
- Easier to inculde external java libraries via maven central for additional functionalities
- Tooling for Java is excellent, tooling for Kawa is not
- Fully static type checking: probably it's because I'm bad at programming, but it helps me a lot
- The old geiser-kawa's scheme implementation logic has been split in 2 projects:
    - [[https://www.gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]: functions that take care of getting data and general functionalities (e.g. output-capturing eval)
    - kawa-geiser:
        - the included maven project
        - gets data and features through kawa-devutil and wraps the result in the geiser protocol
- Possibility to share code between kawa-devutil and Kawa's Language Server
- Since kawa-devutil is now a different project from geiser-kawa, one could use it to avoid re-writing the data-getting logic if she/he wanted to implement a Kawa server for a tool other than geiser (e.g. nrepl, jupyter, swank/slime)

geiser-kawa VS geiser-kawa-scheme - recap table:

|                                | geiser-kawa     | geiser-kawa-scheme |
|--------------------------------+-----------------+--------------------|
| Kawa side written with         | Kawa's Java API | Kawa Scheme        |
| I'm going to add more features | Probably yes    | Probably not       |
