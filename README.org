#+STARTUP: content
* geiser-kawa
** Project description

geiser-kawa is the emacs side of a geiser-kawa implementation that uses [[https://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]] for its Kawa side.

** Supported Kawa versions
:PROPERTIES:
:CUSTOM_ID:       85b51f74-b1b2-4863-a888-0b11580321f3
:END:

Only versions of Kawa > 3.1 are supported, mostly due to the fact that before the 3.1 release some necessary Kawa classes were private.

** Try geiser-kawa without modifying your emacs configuration

1. Get Emacs, Cask, Maven and make them available through your $PATH
2. Clone this repository
3. cd into the cloned dir
4. Tell cask to install emacs dependencies with:
  : cask install
5. Pull [[http://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]] maven dependencies (the first time takes ~1 minute), compile them and start geiser-kawa's scratch buffer and repl with:
  : cask emacs -Q --load quickstart.el

The reason you don't need Kawa to try geiser-kawa is that =quickstart.el= uses the compiled [[https://gitlab.com/groups/kashell/][Kawa's master branch]] that is one of [[http://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]]'s dependencies. To do so =quickstart.el= calls =mvn package= (wrapped by =geiser-kawa-compile-java-dependencies=), which produces a jar that includes all [[http://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]]'s dependencies.

** Supported features

- geiser-related:
    - eval
    - load-file
    - completions
    - module-completions (very fragile atm)
    - autodoc:
        - for scheme procedures
        - for java methods
    - manual lookup:
        - remember to set variable =geiser-kawa-manual-path=
        - should work for both formats:
            - info: using emacs' Info-mode
            - epub: using emacs' eww browser
- kawa- and java-specific:
    - completion for java classes' fields and methods accessed through colon-notation: don't expect java-grade reliability

*** About completion for java classes' fields and methods

The main interactive elisp function is =geiser-kawa-complete-java-fom-at-point=. It's not bound to a key by default.

For this to work you have to:
- use Kawa's type annotations: rememver that the Kawa compiler mostly trusts you and can't actually check
- avoid syntax errors (e.g. unbalanced parentheses, wrong number of children sexps inside a form, etc...)

How it works (the region getting part is quite rudimentray):
1. A region of the current buffer and cursor point inside it are sent to [[https://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]], which uses [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]] for actual functionality. The region of the buffer goes:
     - from either:
         - =(geiser-syntax--pop-to-top)=, if non-nil
         - =(line-beginning-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
     - to either:
         - end of sexp beginning at toplevel, if =(geiser-syntax--pop-to-top)= is non-nil
         - =(line-end-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
2. An arbitrary symbol is added at cursor point, so it can be found again in the AST
3. Code is compiled into Kawa's AST, but not evaluated
4. Various AST "matchers" (functions that check if a certain pattern is found) are tried in order until either:
     - one of them matches: the matcher function itself then also has to tell which class we are completing for
     - none are left: empty data

** Unsupported features

geiser-related:
- macroexpand
- find-file
- symbol-location
- module-location
- symbol-documentation
- module-exports
- callers
- callees
- generic-methods

kawa- and java-specific:
- completion for java package names and class names

** Difference from [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]]

- The Kawa side of geiser-kawa uses [[https://gitlab.com/spellcard199/kawa-geiser][kawa-geiser]], which is written using Kawa's Java API.
- The Kawa side of geiser-kawa-scheme is written directly in Kawa Scheme.
- I'm going to add more features to geiser-kawa but I probably won't port them to geiser-kawa-scheme.

Reasons for rewriting and translating the old geiser-kawa from Kawa Scheme to Java:
- Easier to add as a scripting language in Java projects: just add the jitpack repo and the kawa-geiser dependency (see pom.xml as an example)
- Easier to inculde external java libraries via maven central for additional functionalities (e.g. [[https://github.com/classgraph/classgraph][classgraph]])
- Tooling for Java is excellent, tooling for Kawa is poor
- Fully static type checking: probably it's because I'm bad at programming, but it helps me a lot
- Possibility to share code between kawa-devutil and Kawa's Language Server
- The old geiser-kawa's scheme implementation logic has been split in 2 projects:
    - [[https://www.gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]: functions that take care of getting data and general functionalities (e.g. eval capturing output)
    - kawa-geiser:
        - it's the maven project included with this project, made up by the file =pom.xml= and the directory =src=
        - gets data and features through kawa-devutil and wraps the result in the geiser protocol

The fact that kawa-devutil is now a project separated from geiser means that it may also be used to avoid re-writing the data-getting logic if one wanted to implement a protocol for a tool other than geiser (e.g. nrepl, jupyter, swank/slime).

geiser-kawa VS geiser-kawa-scheme - recap table:

|                                | geiser-kawa     | geiser-kawa-scheme |
|--------------------------------+-----------------+--------------------|
| Kawa side written with         | Kawa's Java API | Kawa Scheme        |
| I'm going to add more features | Probably yes    | Probably not       |

** Cask issue with geiser

If you use geiser as a dependency in a Cask project, Cask eagerly expands the =define-geiser-implementation= macro with =load-file-name= having the wrong value. The result is that geiser implementations in geiser do not work when geiser is managed as a dependency by Cask.

Link to the issue I've opened in Cask: https://github.com/cask/cask/issues/472.

As a (temporary?) workaround, geiser-kawa.el quotes =define-geiser-implementation= and wraps it an =eval= form, and that avoids:
1. macro expansion to happen during cask-cli.el execution
2. =load-file-name= having the wrong value of =<path-to-cask-cli.el>= instead of =<path-to-geiser-impl.el>=
As a side effect, using =(require 'geiser-kawa)= instead of =(require geiser)= also fixes the problem for the other implementations, but for this I don't understand why.

To summarize:
1. geiser-kawa depends on geiser
2. geiser as a dependency does not work with Cask (or vice-versa)
3. If in the emacs instance started with =cask emacs= you use =(require 'geiser-kawa)= instead of =(require 'geiser)=, geiser-kawa.el chain-requires geiser and (for some reason I don't understand) other geiser implementations start working
