#+STARTUP: content
* geiser-kawa
** Project description

=geiser-kawa= is a geiser implementation for Kawa Scheme.

It has 2 parts:
- =geiser-kawa=: elisp package inside the =elisp= directory that gives the name to the whole project
- =kawa-geiser=: maven project written using Kawa's Java API that adds procedures called by geiser-kawa to a Kawa Scheme REPL

** Supported Kawa versions
:PROPERTIES:
:CUSTOM_ID:       85b51f74-b1b2-4863-a888-0b11580321f3
:END:

Only versions of Kawa > 3.1 are supported, mostly due to the fact that before the 3.1 release some necessary Kawa classes were private.

** Supported features

- geiser-related:
    - eval
    - load-file
    - completions
    - module-completions (very fragile atm)
    - macroexpand
    - autodoc:
        - for scheme procedures
        - for java methods
    - manual lookup:
        - remember to set variable =geiser-kawa-manual-path=
        - should work for both formats:
            - info: using emacs' Info-mode
            - epub: using emacs' eww browser
- kawa- and java-specific:
    - [[#7ca3650a-2658-42f0-8274-96f194768e11][Completion for java's package, class, field, method names]]

** Unsupported features

- geiser-related:
    - find-file
    - symbol-location
    - module-location
    - symbol-documentation
    - module-exports
    - callers
    - callees
    - generic-methods

** Try geiser-kawa without modifying your emacs configuration

1. Get Emacs and [[https://github.com/cask/cask][Cask]] and make them available through your $PATH
2. Clone this repository
  : git clone "https://gitlab.com/spellcard199/geiser-kawa.git"
3. cd into the cloned dir:
  : cd geiser-kawa
4. Tell cask to install emacs dependencies:
  : cask install
5. Pull kawa-geiser maven dependencies (the first time takes ~1 minute), compile them and start geiser-kawa's scratch buffer and repl:
  : cask emacs -Q --load quickstart.el
6. You should now have an emacs frame containing a scratch buffer in =geiser-mode= and a repl buffer, both with geiser-kawa support

To try geiser-kawa you need neither Maven nor Kawa:
- =mvnw= ([[https://github.com/takari/maven-wrapper][maven-wrapper]]) takes care of downloading a project-specific Maven version
- kawa-geiser has [[https://gitlab.com/groups/kashell/][Kawa's master branch]] as one of its dependencies. When =quickstart.el= calls =./mvnw package= (wrapped by =geiser-kawa-deps-mvn-package=), it produces a jar that includes kawa-geiser and all its dependencies, including Kawa itself.

** About completion for java's fields, methods and packages
:PROPERTIES:
:CUSTOM_ID:       7ca3650a-2658-42f0-8274-96f194768e11
:END:

The whole project is in a persistent "experimental" state, but this part even more so because it's based on assumptions I'm not sure about.

The main interactive elisp function is =geiser-kawa-complete-fmp-at-point=. By default, it's not bound to a key. (fmp stands for field-method-package).

Supported forms (with issues) are:
    - completion for package and class names: dot notation, like in java
    - completion for field and method names:
        - =field=, =slot-ref=
        - =static-field=
        - =invoke=
        - =invoke-static=
        - colon notation

How it works (the region getting part is quite rudimentray):
1. A region of the current buffer and cursor point inside it are sent to kawa-geiser, which uses [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]] for actual functionality. The region of the buffer goes:
     - from: either:
         - =(geiser-syntax--pop-to-top)=, if non-nil
         - =(line-beginning-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
     - to: either:
         - end of sexp beginning at toplevel, if =(geiser-syntax--pop-to-top)= is non-nil
         - =(line-end-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
2. [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]'s completion method is called passing code and cursor point

You can find some examples and known issues in [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]'README.

** Difference from [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]]

This project (geiser-kawa) is a translation/rewrite of [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]], which has been my first attempt at writing geiser-kawa. After geiser-kawa-scheme confirmed me that a geiser-kawa implementation was possible I decided to rewrite the Kawa side using Kawa's Java API, for the several reasons:
- Easier to add as a scripting language in Java projects: just add the jitpack resolver and this project's repository as a dependency
- Easier to inculde external java libraries via maven central for additional functionalities
- Tooling for Java is excellent, tooling for Kawa is not
- Fully static type checking: probably it's because I'm bad at programming, but it helps me a lot
- The old geiser-kawa's scheme implementation logic has been split in 2 projects:
    - [[https://www.gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]: functions that take care of getting data and general functionalities (e.g. output-capturing eval)
    - kawa-geiser:
        - the included maven project
        - gets data and features through kawa-devutil and wraps the result in the geiser protocol
- Possibility to share code between kawa-devutil and Kawa's Language Server
- Since kawa-devutil is now a different project from geiser-kawa, one could use it to avoid re-writing the data-getting logic if he wanted to implement a Kawa server for a tool other than geiser (e.g. nrepl, jupyter, swank/slime)

geiser-kawa VS geiser-kawa-scheme - recap table:

|                                | geiser-kawa     | geiser-kawa-scheme |
|--------------------------------+-----------------+--------------------|
| Kawa side written with         | Kawa's Java API | Kawa Scheme        |
| I'm going to add more features | Probably yes    | Probably not       |

** Cask issue with geiser

If you use geiser as a dependency in a Cask project, Cask eagerly expands the =define-geiser-implementation= macro with =load-file-name= having the wrong value. The result is that geiser implementations in geiser do not work when geiser is managed as a dependency by Cask.

Link to the issue I've opened in Cask: [[https://github.com/cask/cask/issues/472]].

As a (temporary?) workaround, geiser-kawa.el quotes =define-geiser-implementation= and wraps it an =eval= form, and that avoids:
1. macro expansion to happen during cask-cli.el execution
2. =load-file-name= having the wrong value of =<path-to-cask-cli.el>= instead of =<path-to-geiser-impl.el>=
As a side effect, using =(require 'geiser-kawa)= instead of =(require geiser)= also fixes the problem for the other implementations, but for this I don't understand why.

To summarize:
1. geiser-kawa depends on geiser
2. geiser as a dependency does not work with Cask (or vice-versa)
3. If in the emacs instance started with =cask emacs= you use =(require 'geiser-kawa)= instead of =(require 'geiser)=, geiser-kawa.el chain-requires geiser and (for some reason I don't understand) other geiser implementations start working
