#+STARTUP: content
* geiser-kawa
** Project description

=geiser-kawa= is a geiser implementation for Kawa Scheme.

It has 2 parts:
- =geiser-kawa=: elisp package inside the =elisp= directory that gives the name to the whole project
- =kawa-geiser=: maven project written using Kawa's Java API that adds procedures called by geiser-kawa to a Kawa Scheme REPL

** Supported Kawa versions
:PROPERTIES:
:CUSTOM_ID:       85b51f74-b1b2-4863-a888-0b11580321f3
:END:

Only versions of Kawa > 3.1 are supported, mostly due to the fact that before the 3.1 release some necessary Kawa classes were private.

** Supported features

- geiser-related:
    - eval
    - load-file
    - completions
    - module-completions (very fragile atm)
    - autodoc:
        - for scheme procedures
        - for java methods
    - manual lookup:
        - remember to set variable =geiser-kawa-manual-path=
        - should work for both formats:
            - info: using emacs' Info-mode
            - epub: using emacs' eww browser
- kawa- and java-specific:
    - completion for java classes' fields and methods accessed through colon-notation: don't expect java-grade reliability

** Unsupported features

geiser-related:
- macroexpand
- find-file
- symbol-location
- module-location
- symbol-documentation
- module-exports
- callers
- callees
- generic-methods

kawa- and java-specific:
- completion for java package names and class names

** Try geiser-kawa without modifying your emacs configuration

1. Get Emacs and [[https://github.com/cask/cask][Cask]] and make them available through your $PATH
2. Clone this repository
  : git clone "https://gitlab.com/spellcard199/geiser-kawa.git"
3. cd into the cloned dir:
  : cd geiser-kawa
4. Tell cask to install emacs dependencies:
  : cask install
5. Pull kawa-geiser maven dependencies (the first time takes ~1 minute), compile them and start geiser-kawa's scratch buffer and repl:
  : cask emacs -Q --load quickstart.el
6. You should now have an emacs frame containing a scratch buffer in =geiser-mode= and a repl buffer, both with geiser-kawa support

To try geiser-kawa you need neither Maven nor Kawa:
- =mvnw= ([[https://github.com/takari/maven-wrapper][maven-wrapper]]) takes care of downloading a project-specific Maven version
- kawa-geiser has [[https://gitlab.com/groups/kashell/][Kawa's master branch]] as one of its dependencies. When =quickstart.el= calls =./mvnw package= (wrapped by =geiser-kawa-compile-java-dependencies=), it produces a jar that includes kawa-geiser and all its dependencies, including Kawa itself.

** About completion for java classes' fields and methods

The whole project is in a persistent "experimental" state, but this part even more so.

The main interactive elisp function is =geiser-kawa-complete-java-fom-at-point=. It's not bound to a key by default.

For this to work you have to:
- use Kawa's type annotations: rememver that the Kawa compiler mostly trusts you and can't actually check
- avoid syntax errors (e.g. unbalanced parentheses, wrong number of children sexps inside a form, etc...)

How it works (the region getting part is quite rudimentray):
1. A region of the current buffer and cursor point inside it are sent to kawa-geiser, which uses [[https://gitlab.com/spellcard199/kawa-devutil][kawa-devutil]] for actual functionality. The region of the buffer goes:
     - from: either:
         - =(geiser-syntax--pop-to-top)=, if non-nil
         - =(line-beginning-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
     - to: either:
         - end of sexp beginning at toplevel, if =(geiser-syntax--pop-to-top)= is non-nil
         - =(line-end-position)=, if =(geiser-syntax--pop-to-top)= is =nil=
2. An arbitrary symbol is added at cursor point, so it can be found again in the AST
3. Code is compiled into Kawa's AST, but not evaluated
4. Various AST "matchers" (functions that check if a certain pattern is found) are tried in order until either:
     - one of them matches: the matcher function itself then also has to tell which class we are completing for
     - none are left: empty data

** Difference from [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]]

This project (geiser-kawa) is a translation/rewrite of [[https://gitlab.com/spellcard199/geiser-kawa-scheme][geiser-kawa-scheme]], which has been my first attempt at writing geiser-kawa. After geiser-kawa-scheme confirmed me that a geiser-kawa implementation was possible I decided to rewrite the Kawa side using Kawa's Java API, for the several reasons:
- Easier to add as a scripting language in Java projects: just add the jitpack resolver and this project's repository as a dependency
- Easier to inculde external java libraries via maven central for additional functionalities
- Tooling for Java is excellent, tooling for Kawa is not
- Fully static type checking: probably it's because I'm bad at programming, but it helps me a lot
- The old geiser-kawa's scheme implementation logic has been split in 2 projects:
    - [[https://www.gitlab.com/spellcard199/kawa-devutil][kawa-devutil]]: functions that take care of getting data and general functionalities (e.g. output-capturing eval)
    - kawa-geiser:
        - the included maven project
        - gets data and features through kawa-devutil and wraps the result in the geiser protocol
- Possibility to share code between kawa-devutil and Kawa's Language Server
- Since kawa-devutil is now a different project from geiser-kawa, one could use it to avoid re-writing the data-getting logic if he wanted to implement a Kawa server for a tool other than geiser (e.g. nrepl, jupyter, swank/slime)

geiser-kawa VS geiser-kawa-scheme - recap table:

|                                | geiser-kawa     | geiser-kawa-scheme |
|--------------------------------+-----------------+--------------------|
| Kawa side written with         | Kawa's Java API | Kawa Scheme        |
| I'm going to add more features | Probably yes    | Probably not       |

** Cask issue with geiser

If you use geiser as a dependency in a Cask project, Cask eagerly expands the =define-geiser-implementation= macro with =load-file-name= having the wrong value. The result is that geiser implementations in geiser do not work when geiser is managed as a dependency by Cask.

Link to the issue I've opened in Cask: https://github.com/cask/cask/issues/472.

As a (temporary?) workaround, geiser-kawa.el quotes =define-geiser-implementation= and wraps it an =eval= form, and that avoids:
1. macro expansion to happen during cask-cli.el execution
2. =load-file-name= having the wrong value of =<path-to-cask-cli.el>= instead of =<path-to-geiser-impl.el>=
As a side effect, using =(require 'geiser-kawa)= instead of =(require geiser)= also fixes the problem for the other implementations, but for this I don't understand why.

To summarize:
1. geiser-kawa depends on geiser
2. geiser as a dependency does not work with Cask (or vice-versa)
3. If in the emacs instance started with =cask emacs= you use =(require 'geiser-kawa)= instead of =(require 'geiser)=, geiser-kawa.el chain-requires geiser and (for some reason I don't understand) other geiser implementations start working
